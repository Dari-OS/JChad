package net.jchad.shared.cryptography;

import net.jchad.shared.cryptography.crypterUnits.TagUnit;

import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import java.security.*;

public class Crypter {

    /**
     * Encrypts the input using Advanced Encryption Standard (GCM MODE)
     * @param plainText The text that should get encrypted
     * @param secretKey The secret key
     * @param iv
     * @param tagUnitLength Length of the TagUnit (Default should be 128)
     * @return The encrypted byte-array
     */
    public static byte[] encryptAES(byte[] plainText, SecretKey secretKey, byte[] iv, TagUnit tagUnitLength) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        if (tagUnitLength == null) tagUnitLength = TagUnit.DEFAULT;
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(tagUnitLength.getValue(), iv));
            return cipher.doFinal(plainText);
    }

    /**
     * Decrypts the input using Advanced Encryption Standard (GCM MODE)
     * @param crypticText The text that should get decrypted
     * @param secretKey The secret key
     * @param iv
     * @param tagUnitLength Length of the TagUnit (Default 128)
     * @return the decrypted string
     */
    public static byte[] decryptAES(byte[] crypticText, SecretKey secretKey, byte[] iv, TagUnit tagUnitLength) throws InvalidAlgorithmParameterException, InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException, IllegalBlockSizeException, BadPaddingException {
        if (tagUnitLength == null) tagUnitLength = TagUnit.DEFAULT;

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.DECRYPT_MODE, secretKey, new  GCMParameterSpec(tagUnitLength.getValue(), iv));
        return cipher.doFinal(crypticText);

    }

    /**
     * Encrypts the string using the RSA algorithm
     *
     * @param plainText the text that should get encrypted
     * @param publicKey the public key that encrypts the text. (The public key is used for encryption in order to decrypt with the private key)
     * @return the encrypted text
     */
    public static byte[] encryptRSA(byte[] plainText, Key publicKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            return cipher.doFinal(plainText);
    }

    /**
     * Decrypts the byte array using the RSA algorithm
     *
     * @param encryptedText that byte array that should get decrypted
     * @param privateKey the private key that decrypts the text. (The private key is used for decryption in order to encrypt with the public key)
     * @return
     */
    public static byte[] decryptRSA(byte[] encryptedText, Key privateKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            return cipher.doFinal(encryptedText);

    }


    /**
     * Signs given plain text with the private key to check data integrity
     *
     * @param byteArrayToSign The text that should get signed
     * @param privateKey The private key that gets used for signing
     * @return The signature (this needs to be used to verify the signature)
     */
    public static byte[] sign(byte[] byteArrayToSign, PrivateKey privateKey) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {

            Signature privateSignature = Signature.getInstance("SHA256withRSA");
            privateSignature.initSign(privateKey);
            privateSignature.update(byteArrayToSign);
            return privateSignature.sign();

    }

    /**
     * Verifies the signature with the text byte array
     *
     * @param byteArrayThatWasSigned The signed byte array that got generate by the sign methode
     * @param signature the signature generated by the sign methode
     * @param publicKey the public key
     * @return Returns true if the given signature and signed byte array match
     */
    public static boolean verify(byte[] byteArrayThatWasSigned, byte[] signature, PublicKey publicKey) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
            Signature publicSignature = Signature.getInstance("SHA256withRSA");
            publicSignature.initVerify(publicKey);
            publicSignature.update(byteArrayThatWasSigned);
            return publicSignature.verify(signature);
    }
}
